#include "usermodfx.h"

static float lfo_phase;
static float lfo_depth;

// params
static float modulation_depth;
static float modulation_speed;

const float MIN_TIME_SECONDS = 0.5f;
const float MAX_TIME_SECONDS = 4.5f;

// called upon instantiation of effect, use for initializations 
// see inc/userprg.h for possible values of platform and api
void MODFX_INIT(uint32_t platform, uint32_t api) {
	lfo_phase = 0.0f; 
	lfo_depth = 0.5f;
}

float lfo(float phase) {
	// simple sine wave LFO
	return sinf(phase * 2 * M_PI);
}

void MODFX_PARAM(uint8_t index, int32_t value) {

	const float param = value / 100.0f;

	switch (index)
	{
		case k_user_modfx_param_time: // mapped to knob a
			modulation_speed = MIN_TIME_SECONDS + MAX_TIME_SECONDS * param;
			break;
		case k_user_modfx_param_depth: // mapped to knob b
			modulation_depth = param;
			break;
		default:
			break;
	}
}

void MODFX_PROCESS(const float *main_xn, float *main_yn, 
		const float *sub_xn, float *sub_yn, 
		uint32_t frames){
	for (uint32_t i = 0; i < frames; i++) {

		float lfoValue = sinf(lfo_phase);
		float mod_signal = 1.0f + modulation_depth * lfoValue;

		//apply modulation to the audio signal
		main_yn[i] = main_xn[i] * mod_signal;
		sub_yn[i] = sub_xn[i] * mod_signal;

		//calculate phase increment
		float phaseIncrement = (2*M_PI / (modulation_speed * 48000.0f));
		lfo_phase += phaseIncrement;
		if(lfo_phase > (2*M_PI))
			lfo_phase -= (2*M_PI);
	}
}


